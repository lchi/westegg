// Generated by CoffeeScript 1.4.0
(function() {
  var Cache, fs, path, util;

  fs = require('fs');

  path = require('path');

  util = require('util');

  exports.Cache = Cache = (function() {

    function Cache(options) {
      options = options || {};
      this.verbose = options.verbose || false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.baseDir = options.baseDir || "./";
      this.transform = options.transform || (function(r, cb) {
        return cb(null, r);
      });
      this.missing_file_recheck = options.missing_file_recheck || 1000;
      this.fileCache = {};
      this.fsErrorCache = {};
      this.fsWatchers = {};
    }

    Cache.prototype._log = function(o) {
      var _ref;
      if (this.verbose) {
        if ((_ref = typeof o) === "string" || _ref === "number" || _ref === "boolean") {
          return console.log("westegg: " + o);
        } else {
          return console.log("westegg: " + (util.inspect(o)));
        }
      }
    };

    Cache.prototype.unload = function(filename) {
      var realpath;
      realpath = path.normalize(path.resolve(this.baseDir, filename));
      this._clearFileCache(realpath);
      this._clearFsErrorCache(realpath);
      return this._clearFsWatcher(realpath);
    };

    Cache.prototype.unloadAll = function() {
      var c, v, _, _i, _len, _ref, _ref1, _results;
      _ref = this.fsWatchers;
      for (_ in _ref) {
        v = _ref[_];
        v.close();
      }
      _ref1 = [this.fileCache, this.fsErrorCache, this.fsWatchers];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        c = _ref1[_i];
        _results.push(c = {});
      }
      return _results;
    };

    Cache.prototype.load = function(filename, cb, options) {
      var realpath, start_time,
        _this = this;
      start_time = Date.now();
      options = options || {};
      realpath = path.normalize(path.resolve(this.baseDir, filename));
      this._log("realpath: " + realpath);
      return this._load(realpath, options, function(err, res) {
        var _ref;
        if (err || !res) {
          _ref = ["Couldn't load " + realpath, null], err = _ref[0], res = _ref[1];
        }
        _this._log("" + realpath + " load in " + (Date.now() - start_time) + "ms");
        return cb(err, res);
      });
    };

    Cache.prototype._load = function(filename, options, cb) {
      var v;
      if ((v = this._fileCacheGet(filename))) {
        return cb(null, v);
      } else {
        return this._loadCacheAndMonitor(filename, options, cb);
      }
    };

    Cache.prototype._fileCacheGet = function(filename) {
      if (!(this.fileCache[filename] != null)) {
        return null;
      } else if (!(this.fsErrorCache[filename] != null)) {
        return this.fileCache[filename];
      } else if ((Date.now() - this.fsErrorCache[filename]) < this.missing_file_recheck) {
        return this.fileCache[filename];
      } else {
        return null;
      }
    };

    Cache.prototype._loadCacheAndMonitor = function(filename, options, cb) {
      var fileData, previous_fs_err,
        _this = this;
      previous_fs_err = this.fsErrorCache[filename] != null;
      try {
        fileData = fs.readFileSync(filename, options.encoding || this.defaultEncoding);
        this._clearFsErrorCache(filename);
      } catch (e) {
        this._log("" + e + " when loading " + filename);
        fileData = null;
        this.fsErrorCache[filename] = Date.now();
      }
      if (this.fsErrorCache[filename] && previous_fs_err && this.fileCache[filename]) {
        return cb(null, this.fileCache[filename]);
      } else {
        if (!fileData) {
          this._log("no filedata found for " + filename);
          this._monitorForChanges(filename, options);
          return cb(this.fileCache[filename] = "Error loading " + filename, null);
        } else {
          this._log("calling transform for " + filename);
          return this.transform(fileData, function(err, transformedData) {
            _this._log("in cb for transform for " + filename);
            if (err) {
              delete _this.fileCache[filename];
              _this.fsErrorCache[filename] = Date.now();
            } else {
              _this.fileCache[filename] = transformedData;
              _this._monitorForChanges(filename, options);
            }
            return cb(err, _this.fileCache[filename]);
          });
        }
      }
    };

    Cache.prototype._reloadFileInBkg = function(filename, options) {
      var _this = this;
      return fs.readFile(filename, 'utf8', function(err, fileData) {
        if (err) {
          _this._log("Error when re-reading " + filename + " in background: " + err);
          _this.fsErrorCache[filename] = Date.now();
          fileData = null;
        } else {
          _this._log("" + filename + " updated and ready");
          _this._clearFsErrorCache(filename);
        }
        if (!fileData) {
          return _this.fileCache[filename] = "Error loading " + filename;
        } else {
          return _this.transform(fileData, function(err, transformedData) {
            if (err) {
              delete _this.fileCache[filename];
              return _this.fsErrorCache[filename] = Date.now();
            } else {
              _this.fileCache[filename] = transformedData;
              return _this._monitorForChanges(filename, options);
            }
          });
        }
      });
    };

    Cache.prototype._monitorForChanges = function(filename, options) {
      /*
          we must continuously unwatch/rewatch because some editors/systems invoke a "rename"
          event and we'll end up following the wrong, old 'file' as a new one
          is dropped in its place.
      
          Files that are missing are ignored here because they get picked up by new calls to _loadCacheAndMonitor
      */

      var fsw,
        _this = this;
      if (!(this.fsErrorCache[filename] != null)) {
        fsw = null;
        try {
          this._log("" + filename + " starting fs.watch()");
          return this.fsWatchers[filename] = fsw = fs.watch(filename, {
            persistent: true
          }, function(change) {
            _this._log("" + filename + " closing fs.watch()");
            fsw.close();
            delete _this.fsWatchers[filename];
            _this._monitorForChanges(filename, options);
            return _this._reloadFileInBkg(filename, options);
          });
        } catch (e) {
          this._log("fs.watch() failed for " + filename + "; settings fsErrorCache = true");
          return this.fsErrorCache[filename] = Date.now();
        }
      }
    };

    Cache.prototype._clearFileCache = function(k) {
      return delete this.fileCache[k];
    };

    Cache.prototype._clearFsErrorCache = function(k) {
      return delete this.fsErrorCache[k];
    };

    Cache.prototype._clearFsWatcher = function(k) {
      return delete this.fsWatchers[k];
    };

    return Cache;

  })();

}).call(this);
